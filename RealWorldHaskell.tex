\documentclass[ngerman,a4paper]{report}
\usepackage[english,ngerman]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{geometry}
\usepackage{caption}
\usepackage{hyperref}
%\usepackage{MyriadPro}
\usepackage{graphicx}
%\geometry{verbose,tmargin=3cm,bmargin=3cm,lmargin=3cm,rmargin=3cm}
\usepackage{listings}
\usepackage{paralist}
\usepackage{stmaryrd}
\usepackage{color}
%\usepackage{floatflt}
\usepackage{amsmath}
%\usepackage{amssymb}
\usepackage{float}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\lstset{language=Haskell,
numbers=left,
numberstyle=\tiny\color{gray},
stepnumber=1,
numbersep=5pt,
%basicstyle=\tiny,
%frame = single,
tabsize =2,
breaklines = true,
breakatwhitespace = false,
keywordstyle=\color{blue},          % keyword style
commentstyle=\color{dkgreen},       % comment style
stringstyle=\color{mauve},         % string literal style
literate=%
{Ö}{{\"O}}1
{Ä}{{\"A}}1
{Ü}{{\"U}}1
{ß}{{\ss}}2
{ü}{{\"u}}1
{ä}{{\"a}}1
{ö}{{\"o}}1
}

%\selectlanguage{english}

\renewcommand{\familydefault}{\sfdefault}
\author{Tobias Höppner}
\title{Real World Haskell}
\date{SoSe 2013}

\begin{document}
\maketitle
\tableofcontents
\chapter{VL I}
\section{Motivation}
Warum eigentlich Haskell?\\
Haskell Compiler ist mächtig. Weil die Semantik und Typsystem wilde Sachen erlaubt. Wilde Sachen ermöglichen korrekte Software und sind meist sogar effizienter.\\

\section{Was passiert hier?! - der kleine Webserver}

\subsection{der kleine Webserver}

\lstinputlisting{code/VL/webserver.hs}

Was nicht behandelt wurde:
\begin{compactitem}
\item Fehlerfälle, Exceptions
Haskell unterstütz Exceptions 
\item Effizienz
\end{compactitem}


\subsection{Einbinden von Modulen}
import am Anfang der Datei
\begin{compactitem}
\item System.IO
\item Control.Monad (forever)
\item Text.Printf
\item Network
\item Control.Exception
\item Control.Concurrent
\end{compactitem}

\subsection{Do-Notation}
\begin{lstlisting}
main = do
	putStrLn "hallo user!!"
	putStrLn "xxxx"
	main = p "x" >> p "x"
\end{lstlisting}

ist das gleiche wie
\begin{lstlisting}
main :: IO()
main = do
	args <- getArgs
	read ((!!0) args)
	let x = read ((!! 1) args)
\end{lstlisting}

\subsubsection{Typen}

listenOn: $\_ \leftarrow \ IO\_$

\subsection{\$-Operator}
\begin{lstlisting}
f a b
\end{lstlisting}
a ist eine Fkt. g x k\\
b ist eine Fkt. k fv

\begin{lstlisting}
f $ g x k $ k f v
\end{lstlisting}

\subsection{!!-Operator}
Gibt das angegebene Element aus der Liste zurück.
\begin{lstlisting}
(!!) :: [a] -> Int -> a
let xs = []
ys = [1,2,4]
zs = [1..1378]

zs !! 0
\end{lstlisting}
\section{der größere Webserver}
%code einbinden

\section{builds}
\subsection{mit ghc}
\begin{lstlisting}
ghc x.hs
\end{lstlisting}
Wird unübersichtlich für mehrere Dateien / Module.

\subsection{mit cabal}
\begin{lstlisting}
cabal configure
cabal build
cabal install
\end{lstlisting}

Projekte werden als \textbf{.cabal} gespeichert, sind eleganter und man kann schneller testen.

\section{.(Punkt)-Operator}
\begin{lstlisting}
(.):: (b -> c) -> (a -> b) -> (a -> c)
f . g
\end{lstlisting}

entspricht\\

\begin{lstlisting}
(\x -> f ( g x))
\end{lstlisting}

\section{Generics in Haskell}

\begin{lstlisting}
List e
m k v
\end{lstlisting}

\section{Stdlib - System.IO}
\begin{compactitem}
\item Textinput / Textoutput
\begin{compactitem}
\item Print
\item getLine
\item getChar
\end{compactitem}
\end{compactitem}

\section{Stdlib - System.Environment}
\begin{compactitem}
\item getArgs
\end{compactitem}

\section{Kommentare und Haddock}
\begin{lstlisting}
-- einfacher Kommentar
{- mehrzeiliger Kommentar -}
{- mehrzeiliger Kommentar 
	{- verschachtelter Kommentar -} 
-}
-- | haddoc kommentar
\end{lstlisting}

\section{Keywords}
Programming Guidelines sind brauchbar
\begin{lstlisting}
main = do 
	args <- getArgs
	case args of
		[] -> ...
		["-x"] -> ...
		["-x",b] -> ...
\end{lstlisting}

\chapter{VL II}
\section{Zustände in Haskell}
Gestern wurde der Taschenrechner implementiert, heute sehen wir uns an wie man die eval-Funktion mit Zustandsveränderungen verbessern kann.
\subsection{Eval Funktion in "besser"}
\begin{lstlisting}
data Expr = Const Float | Add Expr Expr | Div Expr Expr

evalO :: Expr -> Float
evalO (Const x) = x = id x
evalO (Add e1 e2) = evalO(e1) + evalO(e2)
evalO (Div e1 e2) = evalO(e1) / evalO(e2)
evalO (Div (Const 1) (Const 0)) = Infinity

evalExpr fC fA fD (Const x) = fC x
evalExpr fC fA fD (Add e1 e2) = fA (evalExpr fC fA fD e1) (evalExpr fC fA fD e2)

data Maybe a = Nothing | Just a

eval1 = eval Expr id (+) fD
	where fD x y = if y == 0
	...

eval2 :: Expr -> Maybe Float
eval2 = evalExpr Just fA fD
	where
		fA e1 e2 = case e1 of
			Nothing -> Nothing
			Just x -> case e2 of
				Nothing -> Nothing
				Just y -> Just (x + y)
		fD e1 e2
			Nothing -> Nothing
			Just x -> case e2 of
				Nothing -> Nothing
				Just y -> Just (x 7 y)

-- Abstrahieren

op :: Maybe a -> (a -> Maybe b) -> Maybe b
op val f = case val of
	Nothing -> Nothing
	Just x -> f x

eval3 = eval Expr Just fA fD
	where 
		fA e1 e2 = e1 'op' (\x -> e2 'op' (\y -> (x + y)))
		fA e1 e2 = e1 'op' (\x -> e2 'op' (\y -> (x / y)))
\end{lstlisting}

\subsection{Zustandsveränderung}

%Bild state_trans1.png
\begin{figure}[h]
	\centering
	\includegraphics[width=150px]{gfx/state_trans1.png}
	\caption{Zustandsveränderungen}
	\label{img:statetrans}
\end{figure}

\begin{lstlisting}
type State = Float

update :: Float -> State -> State
update f = max abs(f)

data St a = S(State -> (a,State))
\end{lstlisting}

"Folgezustand" berechnen

\begin{lstlisting}
apply :: St a -> State -> (a, State)
appl (S f) s = f s'
\end{lstlisting}

Unterschied data / type Listings:\\
\textbf{type} beschreibt wie man einen Zustand definiert.
\textbf{data} beschreibt wie man einen Zustand verändert.

\subsection{Verbesserte Eval-Funktion}
\begin{lstlisting}
eval4 :: Expr -> St Float
eval4 = eval Expr fC fA fD
	where
		fC x = St (\s -> (x,s))
		fA sx sy = St (\s -> let (x, s1) = apply sx s
									(y, s2) = apply sy s1
								in (x + y, update(x+y) s2))
		fA sx sy = St (\s -> let (x, s1) = apply sx s
									(y, s2) = apply sy s1
								in (x / y, update(x/y) s2))
\end{lstlisting}

\subsection{Eval5, noch coolerer}
\begin{lstlisting}
ret x = S (\s -> (x,s))

ap:: St a -> (a -> St b) -> St b
ap st f = S (\s -> let (x, s1) = apply st s
						in apply (f x) s1)

eval5 = evalExpr fC fA fD
	where
		fC x = ret x
		fA sx sy = sx 'ap' (\x ->
					sy 'ap' (\y ->
					s(\s -> (x+y, update abs (x+y) s))))
		fD sx sy = sx 'ap' (\x ->
					sy 'ap' (\y ->
					s(\s -> (x/y, update abs (x/y) s))))
\end{lstlisting}

\subsection{Jetzt ohne Zustände}
Zwei Hilfsfunktionen:\\

\begin{lstlisting}
get :: St State
get = S (\s -> (s,s))

put :: State -> St ()
put s = S(\_ -> ((),s))
\end{lstlisting}

$\rightarrow$

\begin{lstlisting}
stAct :: (State -> State) -> St ()
stAct f = get 'ap' (put.f)

eval6 = evalExpr fC fA fD
	where
		fC = ret
		fA sx sy = sx 'ap' (\x ->
					sy 'ap'	 (\y -> 
					stAct (update(x+y)) 'ap' (\() -> ret (x+y)))))
\end{lstlisting}

\subsection{evals im Vergleich}
\begin{compactitem}
	\item eval3 und eval6 machen das gleiche, jedoch auf unterschiedliche Wege
\end{compactitem}

\section{Monaden}
\begin{lstlisting}
class Monad m where
	return :: a -> m a
	(>>=)	:: m a -> (a -> m b) -> m b
\end{lstlisting}

ap ist eine Monade!\\
In Haskell schreibt man das so:
\begin{lstlisting}
instance Monad Maybe where
	return = Just
	(>>=) = op
\end{lstlisting}

\subsection{die letzte Eval-Funktion (wirklich!)}
So implementiert man ungefähr immer eine Monade\\
\begin{lstlisting}
evalM :: Monad m => Expr -> m Float
evalM = eval Expr fC fA fD
	where
		fC = return
		fA m1 m2 = m1 >>= (x -> 
					m2 >>= (y ->
						... -- irgendwas spezifisches
						return (x+y))))
		fD m1 m2 = m1 >>= (x -> 
					m2 >>= (y ->
						if y == 0 -- irgendwas spezifisches
						then Nothing
						else return (x/y))))
\end{lstlisting}

Für
\begin{lstlisting}
m >>= \x -> fx
\end{lstlisting}
schreibt man auch
\begin{lstlisting}
do x <- m
	return (f x)
\end{lstlisting}
.\\

\begin{lstlisting}
m1 >> m2
\end{lstlisting}
ist nichts anderes als
\begin{lstlisting}
do	m1
		m2
\end{lstlisting}

Für Monaden gibt es 3 Gesetze, die stehen aber in der Doku.

\end{document}
